<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/PDE/libs/highlight/styles/github.min.css"> <link rel=stylesheet  href="/PDE/css/franklin.css"> <link rel=stylesheet  href="/PDE/css/tufte.css"> <link rel=stylesheet  href="/PDE/css/latex.css"> <link rel=stylesheet  href="/PDE/css/adjust.css"> <link rel=stylesheet  href="/PDE/css/bibliography.css"> <link rel=icon  href="/PDE/assets/favicon.png"> <title>Auxiliary functions</title> <div id=layout > <div id=menu > <ul> <li><a style="font-size:larger;" href="/PDE/">Home</a> <li><a style="font-size:larger;" href="/PDE/schedule/">Schedule</a> <li><a style="font-size:larger;" href="/PDE/homework/">Homework</a> <li><a style="font-size:larger;" href="/PDE/labs/">Labs</a> <li><a style="font-size:larger;" href="/PDE/notes/">Notes</a> <li><a style="font-size:larger;" href="/PDE/bibliography/">Bibliography</a> </ul> </div> <div id=main > <div class=franklin-content > <h1 id=auxiliary_functions ><a href="#auxiliary_functions" class=header-anchor >Auxiliary functions</a></h1> <ul> <li><p><a href=shocks_utils.jl >Click here to download this file</a></p> </ul> <pre><code class="julia hljs"><span class=hljs-meta >@inline</span> <span class=hljs-keyword >function</span> mysign_zero(a)
    <span class=hljs-keyword >return</span> (<span class=hljs-number >1.0</span>.*(a .&gt; <span class=hljs-number >0.0</span>) + (-<span class=hljs-number >1.0</span>).* (a .&lt; <span class=hljs-number >0.0</span>))
<span class=hljs-keyword >end</span>

<span class=hljs-meta >@inline</span> <span class=hljs-keyword >function</span> minmod(a, b)
    <span class=hljs-keyword >return</span> <span class=hljs-number >0.5</span>*(mysign_zero(a)+mysign_zero(b))*min(abs(a), abs(b))
<span class=hljs-keyword >end</span>

<span class=hljs-meta >@inline</span> <span class=hljs-keyword >function</span> minmod(a, b, c)
    sgnbc = (mysign_zero(b)+mysign_zero(c)) <span class=hljs-comment >#this is 2 if both are positive, -2 if both are negative, 0 otherwise</span>
    sgnac = (mysign_zero(a)+mysign_zero(c)) <span class=hljs-comment >#this is 2 if both are positive, -2 if both are negative, 0 otherwise</span>
    
    <span class=hljs-keyword >return</span> <span class=hljs-number >0.25</span>*sgnbc*abs(sgnac)*min(abs(a), abs(b),abs(c))
<span class=hljs-keyword >end</span>

<span class=hljs-meta >@inline</span> <span class=hljs-keyword >function</span> minmod(a,b,c,d)
    <span class=hljs-keyword >return</span> <span class=hljs-number >0.125</span>*(mysign_zero(a)+mysign_zero(b))*(abs((mysign_zero(a)+mysign_zero(c))*(mysign_zero(a)+mysign_zero(d))))*min(abs(a),abs(b),abs(c), abs(d))
<span class=hljs-keyword >end</span>

<span class=hljs-keyword >function</span> MM3(a::<span class=hljs-built_in >AbstractFloat</span>, b::<span class=hljs-built_in >AbstractFloat</span>, c::<span class=hljs-built_in >AbstractFloat</span>, weight::<span class=hljs-built_in >AbstractFloat</span>) <span class=hljs-comment >#(2*D0,Dp,Dm)</span>
    
    weight = weight * <span class=hljs-number >2.</span>
  
    <span class=hljs-keyword >if</span> (abs(a) &lt;= (weight*abs(b))) 
        <span class=hljs-keyword >return</span> (abs(a) &lt;= (weight*abs(c))) ? abs(a)*<span class=hljs-number >.5</span> : abs(c) 
    <span class=hljs-keyword >else</span> 
        <span class=hljs-keyword >return</span> (abs(b) &lt;= abs(c)) ? abs(b) : abs(c)
    <span class=hljs-keyword >end</span> 
<span class=hljs-keyword >end</span>
<span class=hljs-comment >#MM3(4.,-1.,4.,2.5)</span>
<span class=hljs-keyword >function</span> MM3N(a::<span class=hljs-built_in >AbstractFloat</span>, b::<span class=hljs-built_in >AbstractFloat</span>, c::<span class=hljs-built_in >AbstractFloat</span>) <span class=hljs-comment >#(2*D0,Dp,Dm)</span>
    <span class=hljs-keyword >if</span> (abs(a) &lt;= abs(b))
        <span class=hljs-keyword >return</span> (abs(a) &lt;= abs(c)) ? abs(a) : abs(c) 
    <span class=hljs-keyword >else</span> 
        <span class=hljs-keyword >return</span> (abs(b) &lt;= abs(c)) ? abs(b) : abs(c)
    <span class=hljs-keyword >end</span> 
<span class=hljs-keyword >end</span>
<span class=hljs-comment >#MM3(4.,-1.,4.,2.5)</span>


<span class=hljs-keyword >function</span> DMM(a::<span class=hljs-built_in >AbstractFloat</span>, b::<span class=hljs-built_in >AbstractFloat</span>)
    <span class=hljs-keyword >return</span> <span class=hljs-number >0.5</span> * (mysign_zero(a) + mysign_zero(b)) * minimum([abs(a),abs(b)])
<span class=hljs-keyword >end</span>
<span class=hljs-comment >#DMM(2.,2.)</span>

<span class=hljs-keyword >function</span> DM4(a::<span class=hljs-built_in >AbstractFloat</span>, b::<span class=hljs-built_in >AbstractFloat</span>, c::<span class=hljs-built_in >AbstractFloat</span>, d::<span class=hljs-built_in >AbstractFloat</span>)
    <span class=hljs-keyword >return</span> <span class=hljs-number >0.125</span> * (mysign_zero(a) + mysign_zero(b)) * abs((mysign_zero(a) + mysign_zero(c)) * (mysign_zero(a) + mysign_zero(d))) * minimum([abs(a),abs(b),abs(c),abs(d)])
<span class=hljs-keyword >end</span>
<span class=hljs-comment >#DM4(1.,2.,3.,0.)</span>

<span class=hljs-comment >#método de Kurganov-Tadmor</span>

<span class=hljs-keyword >function</span> KT!(dfields, fields, par, t)
    <span class=hljs-comment >#Los parámetros son h, θ, funciones auxiliares y vectores auxiliares</span>
    eqpars, h::<span class=hljs-built_in >Float64</span>, θ::<span class=hljs-built_in >Float64</span>, Fx!, MaxSpeed, N::<span class=hljs-built_in >Int64</span>, N_FIELDS::<span class=hljs-built_in >Int32</span>, auxvectors = par
    Dm, D, Dp, u_mm, u_mp, u_pm, u_pp, F_mm, F_mp, F_pm, F_pp, H_m, H_p = auxvectors

    <span class=hljs-keyword >for</span> idx <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:N
        idxll = mod(((idx-<span class=hljs-number >2</span>) - <span class=hljs-number >1</span>),N) + <span class=hljs-number >1</span>
        idxl = mod(((idx-<span class=hljs-number >1</span>) - <span class=hljs-number >1</span>),N) + <span class=hljs-number >1</span>
        idxr = mod(((idx+<span class=hljs-number >1</span>) - <span class=hljs-number >1</span>),N) + <span class=hljs-number >1</span>
        idxrr = mod(((idx+<span class=hljs-number >2</span>) - <span class=hljs-number >1</span>),N) + <span class=hljs-number >1</span>
        
        fll = <span class=hljs-meta >@view</span> fields[idxll,:]
        fl = <span class=hljs-meta >@view</span> fields[idxl,:]
        f = <span class=hljs-meta >@view</span> fields[idx,:]
        fr = <span class=hljs-meta >@view</span> fields[idxr,:]
        frr = <span class=hljs-meta >@view</span> fields[idxrr,:]
        
        @. Dm = minmod(<span class=hljs-number >0.5</span> *(f - fll), θ*(f-fl), θ*(fl-fll)) <span class=hljs-comment ># * h</span>
        @. D  = minmod(<span class=hljs-number >0.5</span> *(fr - fl), θ*(fr-f), θ*(f-fl)) <span class=hljs-comment ># * h</span>
        @. Dp = minmod(<span class=hljs-number >0.5</span>*(frr-f), θ*(frr-fr), θ*(fr-f)) <span class=hljs-comment ># * h</span>
        @. u_mm = fl + <span class=hljs-number >0.5</span>*Dm  <span class=hljs-comment >#/h</span>
        @. u_mp = f - <span class=hljs-number >0.5</span>*D <span class=hljs-comment >#/h</span>
        @. u_pm = f + <span class=hljs-number >0.5</span>*D <span class=hljs-comment >#/h</span>
        @. u_pp = fr - <span class=hljs-number >0.5</span>*Dp <span class=hljs-comment >#/h</span>
        
        Fx!(F_mm, u_mm, eqpars)
        Fx!(F_mp, u_mp, eqpars)
        Fx!(F_pm, u_pm, eqpars)
        Fx!(F_pp, u_pp, eqpars)
        
        
        a_m::<span class=hljs-built_in >Float64</span> = max(MaxSpeed(u_mm, eqpars), MaxSpeed(u_mp, eqpars))       
        a_p::<span class=hljs-built_in >Float64</span> = max(MaxSpeed(u_pm, eqpars), MaxSpeed(u_pp, eqpars))        

        
        @. H_m = <span class=hljs-number >0.5</span> * (F_mp + F_mm) - <span class=hljs-number >0.5</span> * a_m * (u_mp - u_mm)
        @. H_p = <span class=hljs-number >0.5</span> * (F_pp + F_pm) - <span class=hljs-number >0.5</span> * a_p * (u_pp - u_pm)
        
        @. dfields[idx, :] = -h*(H_p - H_m)
    <span class=hljs-keyword >end</span>
<span class=hljs-keyword >end</span>

<span class=hljs-keyword >function</span> createKTauxvectors(N_FIELDS)
    D = <span class=hljs-built_in >Array</span>{<span class=hljs-built_in >Float64</span>}(<span class=hljs-literal >undef</span>, N_FIELDS)
    Dm = copy(D)
    Dp = copy(D)
    umm = copy(D)
    ump = copy(D)
    upm = copy(D)
    upp = copy(D)
    Fmm = copy(D)
    Fmp = copy(D)
    Fpm = copy(D)
    Fpp = copy(D)
    Hm = copy(D)
    Hp = copy(D)
    <span class=hljs-keyword >return</span> (Dm, D, Dp, umm, ump, upm, upp, Fmm, Fmp, Fpm, Fpp, Hm, Hp)
<span class=hljs-keyword >end</span>



<span class=hljs-comment >#==================================MP5=====================================#</span>

<span class=hljs-comment >#Reconstrucción</span>
<span class=hljs-keyword >function</span> MP5reconstruction!(Vl, Vjmm, Vjm, Vj, Vjp, Vjpp, N_Fields)
    B1 = <span class=hljs-number >0.0166666666666666667</span>  <span class=hljs-comment >#1/60</span>
    B2 = <span class=hljs-number >1.3333333333333333333</span>  <span class=hljs-comment >#4/3</span>
    eps = <span class=hljs-number >1e-10</span>
    ALPHA = <span class=hljs-number >4.0</span>
    <span class=hljs-comment >#=Vjmm = V[1]
    Vjm = V[2]
    Vj = V[3]
    Vjp = V[4]
    Vjpp = V[5]=#</span>
    <span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:N_Fields
        Vor = B1*(<span class=hljs-number >2.0</span>*Vjmm[i] - <span class=hljs-number >13.0</span>*Vjm[i] + <span class=hljs-number >47.0</span>*Vj[i] + <span class=hljs-number >27</span>*Vjp[i] - <span class=hljs-number >3.0</span>*Vjpp[i]) <span class=hljs-comment >#=This is the original interpolation.
                                                                       All that follows is the application of 
                                                                       limiters to treat shocks=#</span>
        Vmp = Vj[i] + minmod(Vjp[i]-Vj[i], ALPHA*(Vj[i]-Vjm[i]))  <span class=hljs-comment >#mp = monotonicity preserving. It&#x27;s the median between v_j, v_(j+1)</span>
                                                  <span class=hljs-comment >#and an upper limit v^UL = v_j+ALPHA(v_j-v_(j-1))</span>
        <span class=hljs-keyword >if</span> ((Vor-Vj[i])*(Vor-Vmp)) &lt; eps             <span class=hljs-comment >#this condition is equivalent to asking vl in [vj, v^{MP}]</span>
            Vl[i] = Vor <span class=hljs-comment >#vl = v^{L}_{j+1/2}</span>
        <span class=hljs-keyword >else</span>
            djm1 = Vjmm[i] - <span class=hljs-number >2.0</span>*Vjm[i] + Vj[i]
            dj = Vjm[i] - <span class=hljs-number >2</span>*Vj[i] + Vjp[i]
            djp1 = Vj[i] - <span class=hljs-number >2.0</span>*Vjp[i] + Vjpp[i]
            dm4jph = minmod(<span class=hljs-number >4</span>*dj - djp1, <span class=hljs-number >4</span>*djp1-dj, dj, djp1)  <span class=hljs-comment >#ph = plus half (+1/2)</span>
            dm4jmh = minmod(<span class=hljs-number >4</span>*dj - djm1, <span class=hljs-number >4</span>*djm1-dj, dj, djm1)  <span class=hljs-comment >#mh = minus half (-1/2)</span>
            <span class=hljs-comment >#d^{M4}_{j+1/2} = \minmod(4d_{j}-d_{j+1},4d_{j+1}-d_{j}, d_{j}, d_{j+1})</span>
            Vul = Vj[i] + ALPHA*(Vj[i] - Vjm[i])   <span class=hljs-comment >#upper limit</span>
            Vav = <span class=hljs-number >0.5</span>*(Vj[i] + Vjp[i])          <span class=hljs-comment >#average</span>
            Vmd = Vav - <span class=hljs-number >0.5</span>*dm4jph        <span class=hljs-comment >#Vmedian</span>
            Vlc = Vj[i] + <span class=hljs-number >0.5</span>*(Vj[i]-Vjm[i]) + B2*dm4jmh
            Vmin = max(min(Vj[i], Vjp[i], Vmd), min(Vj[i], Vul, Vlc));
            Vmax = min(max(Vj[i], Vjp[i], Vmd), max(Vj[i], Vul, Vlc));
            Vl[i] = Vor + minmod(Vmin-Vor, Vmax-Vor) <span class=hljs-comment >#this places Vor between Vmin and Vmax</span>
        <span class=hljs-keyword >end</span>
    <span class=hljs-keyword >end</span>
<span class=hljs-keyword >end</span> 

<span class=hljs-comment >#Implementación de MP5 con el Flux Splitting de Lax</span>

<span class=hljs-keyword >function</span> mp5!(dfields, fields, par, t) <span class=hljs-comment ># j is the grid position</span>
    <span class=hljs-comment >#asumimos u unidimensional por ahora</span>
    par_eq, h, N, N_Fields, Fx!, Speed_max, auxvectors = par
    F_Mm3, F_Mm2, F_Mm1, F_M, F_Mp1, F_Mp2, F_Mp3, F_Pm3, F_Pm2, F_Pm1, F_P, F_Pp1, F_Pp2, F_Pp3, F_LP, F_LM, F_RP, F_RM, H_m, H_p = auxvectors
    

    <span class=hljs-comment >#nota: f minuscula o u se usa para hablar de campos, F mayúscula para hablar de Flujos.</span>
    
    <span class=hljs-keyword >for</span> idx <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:N
        <span class=hljs-comment >#first we defined shifted indices</span>
        idxm3 = mod(((idx-<span class=hljs-number >3</span>) - <span class=hljs-number >1</span>),N) + <span class=hljs-number >1</span>
        idxm2 = mod(((idx-<span class=hljs-number >2</span>) - <span class=hljs-number >1</span>),N) + <span class=hljs-number >1</span>
        idxm1 = mod(((idx-<span class=hljs-number >1</span>) - <span class=hljs-number >1</span>),N) + <span class=hljs-number >1</span>
        idxp1 = mod(((idx+<span class=hljs-number >1</span>) - <span class=hljs-number >1</span>),N) + <span class=hljs-number >1</span>
        idxp2 = mod(((idx+<span class=hljs-number >2</span>) - <span class=hljs-number >1</span>),N) + <span class=hljs-number >1</span>
        idxp3 = mod(((idx+<span class=hljs-number >3</span>) - <span class=hljs-number >1</span>),N) + <span class=hljs-number >1</span>
        
    
        um3 = <span class=hljs-meta >@view</span> fields[idxm3,:]
        um2 = <span class=hljs-meta >@view</span> fields[idxm2,:]
        um1 = <span class=hljs-meta >@view</span> fields[idxm1,:]
        u   = <span class=hljs-meta >@view</span> fields[idx,:]
        up1 = <span class=hljs-meta >@view</span> fields[idxp1,:]
        up2 = <span class=hljs-meta >@view</span> fields[idxp2,:]
        up3 = <span class=hljs-meta >@view</span> fields[idxp3,:]
        
        S_MAX = max(Speed_max(up3, par_eq), Speed_max(um3, par_eq), 
            Speed_max(up2, par_eq), Speed_max(um2, par_eq), Speed_max(up1, par_eq), 
            Speed_max(um1, par_eq), Speed_max(u, par_eq)) <span class=hljs-comment >#maximum speed</span>
        
        Fx!(F_Pm3, um3, par_eq)
        Fx!(F_Pm2, um2, par_eq)
        Fx!(F_Pm1, um1, par_eq)
        Fx!(F_P, u, par_eq)
        Fx!(F_Pp1, up1, par_eq)
        Fx!(F_Pp2, up2, par_eq)
        Fx!(F_Pp3, up3, par_eq)
        
        
        @. F_Mm3 = <span class=hljs-number >0.5</span> * (F_Pm3 - S_MAX * um3)
        @. F_Mm2 = <span class=hljs-number >0.5</span> * (F_Pm2 - S_MAX * um2)
        @. F_Mm1 = <span class=hljs-number >0.5</span> * (F_Pm1 - S_MAX * um1)
        @. F_M   = <span class=hljs-number >0.5</span> * (F_P   - S_MAX * u)
        @. F_Mp1 = <span class=hljs-number >0.5</span> * (F_Pp1 - S_MAX * up1)
        @. F_Mp2 = <span class=hljs-number >0.5</span> * (F_Pp2 - S_MAX * up2)
        @. F_Mp3 = <span class=hljs-number >0.5</span> * (F_Pp3 - S_MAX * up3)
        @. F_Pm3 = <span class=hljs-number >0.5</span> * (F_Pm3 + S_MAX * um3)
        @. F_Pm2 = <span class=hljs-number >0.5</span> * (F_Pm2 + S_MAX * um2)
        @. F_Pm1 = <span class=hljs-number >0.5</span> * (F_Pm1 + S_MAX * um1)
        @. F_P   = <span class=hljs-number >0.5</span> * (F_P   + S_MAX * u)
        @. F_Pp1 = <span class=hljs-number >0.5</span> * (F_Pp1 + S_MAX * up1)
        @. F_Pp2 = <span class=hljs-number >0.5</span> * (F_Pp2 + S_MAX * up2)
        @. F_Pp3 = <span class=hljs-number >0.5</span> * (F_Pp3 + S_MAX * up3)
    
        MP5reconstruction!(F_RM, F_Mp2, F_Mp1,  F_M,  F_Mm1, F_Mm2, N_Fields)
        MP5reconstruction!(F_LM, F_Pm3, F_Pm2, F_Pm1, F_P,  F_Pp1, N_Fields)
        MP5reconstruction!(F_LP, F_Pm2, F_Pm1,  F_P,  F_Pp1, F_Pp2, N_Fields)
        MP5reconstruction!(F_RP, F_Mp3, F_Mp2, F_Mp1, F_M,  F_Mm1, N_Fields)
        
        @. H_p = F_LP + F_RP
        @. H_m = F_LM + F_RM
        
        @. dfields[idx, :] = -h*(H_p - H_m)
        
    <span class=hljs-keyword >end</span>
    
<span class=hljs-keyword >end</span>

<span class=hljs-keyword >function</span> createMP5auxvectors(N_FIELDS)
    F_P = <span class=hljs-built_in >Array</span>{<span class=hljs-built_in >Float64</span>}(<span class=hljs-literal >undef</span>, N_FIELDS)
    F_P = copy(F_P)
    F_M = copy(F_P)
    F_Pm3 = copy(F_P)
    F_Pm2 = copy(F_P)
    F_Pm1 = copy(F_P)
    F_Pp1 = copy(F_P)
    F_Pp2 = copy(F_P)
    F_Pp3 = copy(F_P)
    F_Mm3 = copy(F_P)
    F_Mm2 = copy(F_P)
    F_Mm1 = copy(F_P)
    F_Mp1 = copy(F_P)
    F_Mp2 = copy(F_P)
    F_Mp3 = copy(F_P)

    F_LP = copy(F_P)
    F_LM = copy(F_P)
    F_RM = copy(F_P)
    F_RP = copy(F_P)
    H_m = copy(F_P)
    H_p = copy(F_P)
    <span class=hljs-keyword >return</span> (F_Mm3, F_Mm2, F_Mm1, F_M, F_Mp1, F_Mp2, F_Mp3, F_Pm3, F_Pm2, F_Pm1, F_P, F_Pp1, F_Pp2, F_Pp3, F_LP, F_LM, F_RP, F_RM, H_m, H_p)
<span class=hljs-keyword >end</span>

<span class=hljs-comment >#====================WENOZ====================#</span>

<span class=hljs-keyword >function</span> createWENOZvectors(N_FIELDS)
    F_Mm3 = <span class=hljs-built_in >Array</span>{<span class=hljs-built_in >Float64</span>}(<span class=hljs-literal >undef</span>, N_FIELDS)
    F_Mm2 = copy(F_Mm3)
    F_Mm1 = copy(F_Mm3)
    F_M   = copy(F_Mm3)
    F_Mp1 = copy(F_Mm3)
    F_Mp2 = copy(F_Mm3)
    F_Mp3 = copy(F_Mm3)
    F_Pm3 = copy(F_Mm3)
    F_Pm2 = copy(F_Mm3)
    F_Pm1 = copy(F_Mm3)
    F_P   = copy(F_Mm3)
    F_Pp1 = copy(F_Mm3)
    F_Pp2 = copy(F_Mm3)
    F_Pp3 = copy(F_Mm3)
    F_LP  = copy(F_Mm3)
    F_LM  = copy(F_Mm3)
    F_RP  = copy(F_Mm3)
    F_RM  = copy(F_Mm3)
    H_m   = copy(F_Mm3)
    H_p   = copy(F_Mm3)
    sourcevec = copy(F_Mm3)
    
    <span class=hljs-keyword >return</span> (F_Mm3, F_Mm2, F_Mm1, F_M, F_Mp1, F_Mp2, F_Mp3, F_Pm3, F_Pm2, F_Pm1, F_P, F_Pp1, F_Pp2, F_Pp3, F_LP, F_LM, F_RP, F_RM, H_m, H_p, sourcevec)
<span class=hljs-keyword >end</span>

<span class=hljs-keyword >function</span> WENOZreconstruction!(Vl, Vjmm, Vjm, Vj, Vjp, Vjpp, N_Fields)
    B1 = <span class=hljs-number >1.0833333333333333333</span>  <span class=hljs-comment >#13/12</span>
    B2 = <span class=hljs-number >0.1666666666666666666</span>  <span class=hljs-comment >#1/6</span>
    
    eps = <span class=hljs-number >1e-40</span>

    <span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:N_Fields
        Q0 = <span class=hljs-number >2.0</span>*Vj[i] +<span class=hljs-number >5.0</span>*Vjp[i] - <span class=hljs-number >1.0</span>*Vjpp[i]
        Q1 = -Vjm[i] + <span class=hljs-number >5.0</span>*Vj[i] + <span class=hljs-number >2.0</span>*Vjp[i]
        Q2 = <span class=hljs-number >2.0</span>*Vjmm[i] - <span class=hljs-number >7.0</span>*Vjm[i] + <span class=hljs-number >11</span>* Vj[i]


        β<span class=hljs-number >0</span> =  B1*(Vj[i] - <span class=hljs-number >2</span>*Vjp[i] + Vjpp[i])^<span class=hljs-number >2</span> + <span class=hljs-number >0.25</span>*(<span class=hljs-number >3</span>*Vj[i] - <span class=hljs-number >4</span>*Vjp[i]+ Vjpp[i])^<span class=hljs-number >2</span>
        β<span class=hljs-number >1</span> =  B1*(Vjm[i] - <span class=hljs-number >2</span>*Vj[i] + Vjp[i])^<span class=hljs-number >2</span> + <span class=hljs-number >0.25</span>*(Vjm[i] - Vjp[i])^<span class=hljs-number >2</span>
        β<span class=hljs-number >2</span> =  B1*(Vjmm[i] - <span class=hljs-number >2</span>*Vjm[i] + Vj[i])^<span class=hljs-number >2</span> + <span class=hljs-number >0.25</span>*(Vjmm[i] - <span class=hljs-number >4</span>*Vjm[i]+ <span class=hljs-number >3</span>*Vj[i])^<span class=hljs-number >2</span>


        τ<span class=hljs-number >5</span> = abs(β<span class=hljs-number >2</span> - β<span class=hljs-number >0</span>)

        α<span class=hljs-number >0</span> = <span class=hljs-number >0.3</span>*(<span class=hljs-number >1.0</span> + (τ<span class=hljs-number >5</span>/(β<span class=hljs-number >0</span> + eps))^<span class=hljs-number >2</span>)
        α<span class=hljs-number >1</span> = <span class=hljs-number >0.6</span>*(<span class=hljs-number >1.0</span> + (τ<span class=hljs-number >5</span>/(β<span class=hljs-number >1</span> + eps))^<span class=hljs-number >2</span>)
        α<span class=hljs-number >2</span> = <span class=hljs-number >0.1</span>*(<span class=hljs-number >1.0</span> + (τ<span class=hljs-number >5</span>/(β<span class=hljs-number >2</span> + eps))^<span class=hljs-number >2</span>)

        alphasum = (α<span class=hljs-number >0</span> + α<span class=hljs-number >1</span> + α<span class=hljs-number >2</span>)

        Vl[i] = (α<span class=hljs-number >0</span>*Q0 + α<span class=hljs-number >1</span>*Q1 + α<span class=hljs-number >2</span>*Q2)*B2/alphasum
    <span class=hljs-keyword >end</span>
<span class=hljs-keyword >end</span> 


<span class=hljs-keyword >function</span> wenoz!(dfields, fields, par, t) <span class=hljs-comment ># j is the grid position</span>
    <span class=hljs-comment >#asumimos u unidimensional por ahora</span>
    par_eq, h, N, N_Fields, Fx!, Speed_max, auxvecs = par
    F_Mm3, F_Mm2, F_Mm1, F_M, F_Mp1, F_Mp2, F_Mp3, F_Pm3, F_Pm2, F_Pm1, F_P, F_Pp1, F_Pp2, F_Pp3, F_LP, F_LM, F_RP, F_RM, H_m, H_p, sourcevec = auxvecs
    
    <span class=hljs-comment >#nota: f minuscula o u se usa para hablar de campos, F mayúscula para hablar de Flujos.</span>
    
    <span class=hljs-keyword >for</span> idx <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:N
        <span class=hljs-comment >#first we defined shifted indices. The mod function make the indices periodic.</span>
        <span class=hljs-comment >#Primero definimos los indices desplazados. La función mod hace que los índices sean periódicos.</span>
        idxm3 = mod(((idx-<span class=hljs-number >3</span>) - <span class=hljs-number >1</span>),N) + <span class=hljs-number >1</span>
        idxm2 = mod(((idx-<span class=hljs-number >2</span>) - <span class=hljs-number >1</span>),N) + <span class=hljs-number >1</span>
        idxm1 = mod(((idx-<span class=hljs-number >1</span>) - <span class=hljs-number >1</span>),N) + <span class=hljs-number >1</span>
        idxp1 = mod(((idx+<span class=hljs-number >1</span>) - <span class=hljs-number >1</span>),N) + <span class=hljs-number >1</span>
        idxp2 = mod(((idx+<span class=hljs-number >2</span>) - <span class=hljs-number >1</span>),N) + <span class=hljs-number >1</span>
        idxp3 = mod(((idx+<span class=hljs-number >3</span>) - <span class=hljs-number >1</span>),N) + <span class=hljs-number >1</span>
        
        
        <span class=hljs-comment >#We give a name to the fields on the stencil points (idx-3, idx-2, idx-1, idx, idx+1, idx+2 and idx+3)</span>
        <span class=hljs-comment >#Le damos un nombre a los campos en los puntos del stencil (idx-3, idx-2, idx-1, idx, idx+1, idx+2 y idx+3)</span>
        um3 = <span class=hljs-meta >@view</span> fields[idxm3,:]
        um2 = <span class=hljs-meta >@view</span> fields[idxm2,:]
        um1 = <span class=hljs-meta >@view</span> fields[idxm1,:]
        u   = <span class=hljs-meta >@view</span> fields[idx,:]
        up1 = <span class=hljs-meta >@view</span> fields[idxp1,:]
        up2 = <span class=hljs-meta >@view</span> fields[idxp2,:]
        up3 = <span class=hljs-meta >@view</span> fields[idxp3,:]
        
        <span class=hljs-comment >#We calculate the maximum propagation speed inside the stencil</span>
        <span class=hljs-comment >#Calculamos la velocidad de propagación máxima dentro del stencil</span>
        S_MAX = max(Speed_max(up3, par_eq), Speed_max(um3, par_eq), 
            Speed_max(up2, par_eq), Speed_max(um2, par_eq), Speed_max(up1, par_eq), 
            Speed_max(um1, par_eq), Speed_max(u, par_eq)) <span class=hljs-comment >#maximum speed</span>
        
        <span class=hljs-comment >#We calculate the fluxes on each of the points.</span>
        <span class=hljs-comment >#Calculamos los flujos en los puntos</span>
        Fx!(F_Pm3, um3, par_eq)
        Fx!(F_Pm2, um2, par_eq)
        Fx!(F_Pm1, um1, par_eq)
        Fx!(F_P, u, par_eq)
        Fx!(F_Pp1, up1, par_eq)
        Fx!(F_Pp2, up2, par_eq)
        Fx!(F_Pp3, up3, par_eq)
        
        <span class=hljs-comment >#We make the Lax-Friedrichs Flux-Splitting</span>
        <span class=hljs-comment >#Hacemos la separación de flujos de Lax-Friedrichs</span>
        @. F_Mm3 = <span class=hljs-number >0.5</span> * (F_Pm3 - S_MAX * um3)
        @. F_Mm2 = <span class=hljs-number >0.5</span> * (F_Pm2 - S_MAX * um2)
        @. F_Mm1 = <span class=hljs-number >0.5</span> * (F_Pm1 - S_MAX * um1)
        @. F_M   = <span class=hljs-number >0.5</span> * (F_P   - S_MAX * u)
        @. F_Mp1 = <span class=hljs-number >0.5</span> * (F_Pp1 - S_MAX * up1)
        @. F_Mp2 = <span class=hljs-number >0.5</span> * (F_Pp2 - S_MAX * up2)
        @. F_Mp3 = <span class=hljs-number >0.5</span> * (F_Pp3 - S_MAX * up3)
        @. F_Pm3 = <span class=hljs-number >0.5</span> * (F_Pm3 + S_MAX * um3)
        @. F_Pm2 = <span class=hljs-number >0.5</span> * (F_Pm2 + S_MAX * um2)
        @. F_Pm1 = <span class=hljs-number >0.5</span> * (F_Pm1 + S_MAX * um1)
        @. F_P   = <span class=hljs-number >0.5</span> * (F_P   + S_MAX * u)
        @. F_Pp1 = <span class=hljs-number >0.5</span> * (F_Pp1 + S_MAX * up1)
        @. F_Pp2 = <span class=hljs-number >0.5</span> * (F_Pp2 + S_MAX * up2)
        @. F_Pp3 = <span class=hljs-number >0.5</span> * (F_Pp3 + S_MAX * up3)
        <span class=hljs-comment >#We reconstruct the fluxes in i-1/2 and i+1/2 for the split fluxes</span>
        <span class=hljs-comment >#Hacemos la reconstrucción de flujos en i-1/2 y i+1/2 para los dos flujos separados</span>
        WENOZreconstruction!(F_RM, F_Mp2, F_Mp1,  F_M,  F_Mm1, F_Mm2, N_Fields)
        WENOZreconstruction!(F_LM, F_Pm3, F_Pm2, F_Pm1, F_P,  F_Pp1, N_Fields)
        WENOZreconstruction!(F_LP, F_Pm2, F_Pm1,  F_P,  F_Pp1, F_Pp2, N_Fields)
        WENOZreconstruction!(F_RP, F_Mp3, F_Mp2, F_Mp1, F_M,  F_Mm1, N_Fields)
        
        <span class=hljs-comment >#We add the reconstructed split fluxes.</span>
        @. H_p = F_LP + F_RP
        @. H_m = F_LM + F_RM

        
        <span class=hljs-comment >#We calculate the temporal derivatives</span>
        <span class=hljs-comment >#Calculamos la derivada temporal</span>
        @. dfields[idx, :] = -h*(H_p - H_m)
    <span class=hljs-keyword >end</span>
<span class=hljs-keyword >end</span></code></pre> <div class=back-to-top > <span><a href="#" title="Back to Top"><i class="fa fa-chevron-circle-up"></i></a></span> </div> <div class=page-foot > Last modified: June 17, 2025. <br> Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>. </div> </div> </div> </div> <script src="/PDE/libs/highlight/highlight.min.js"></script> <script>hljs.highlightAll();hljs.configure({tabReplace: ' '});</script>